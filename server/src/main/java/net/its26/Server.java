/*
 * This source file was generated by the Gradle 'init' task
 */
package net.its26;

import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.Optional;
import java.util.function.Function;

public class Server 
{
    private static final String NAME_CERT_ROOT = "rootCA.crt";
    private static final String NAME_CERT_SERVER = "serverCert.crt";
    private static final String NAME_KEY_SERVER = "serverCert.key";
    private static final int LISTEN_PORT = 12345;

    private static class ServerApp
    {
        enum ServerState
        {
            WAIT_MSG01,
            WAIT_MSG03,
            WAIT_MSG05,
            TERMINATED
        }

        private final Socket socket;
        private final X509Certificate rootCertificate;
        private final X509Certificate serverCertificate;
        private final PrivateKey serverPrivateKey;
        private final Integer serverRandom;
        private final RSA.PrivatePublicKey homeMadePrivPubKeys;
        private final DSA.KeyPair dsaKeyPair;

        private ServerState state;
        private Optional<Integer> clientRandom;
        private Optional<X509Certificate> clientCertificate;

        public ServerApp(Socket socket, X509Certificate rootCertificate, X509Certificate serverCertificate, PrivateKey serverPrivateKey)
        {
            this.socket = socket;
            this.rootCertificate = rootCertificate;
            this.serverCertificate = serverCertificate;
            this.serverPrivateKey = serverPrivateKey;
            this.serverRandom = ClientServer.generateRandom();
            this.homeMadePrivPubKeys = RSA.generateKeyPair(2048);
            dsaKeyPair = DSA.generateKeyPair(4); // Pick a value [0..8]

            this.state = ServerState.WAIT_MSG01;
            this.clientRandom = Optional.empty();
            this.clientCertificate = Optional.empty();
        }

        public void doProtocol()
        {
            try
            {
                while(state != ServerState.TERMINATED)
                {
                    byte rxMessage[] = ClientServer.receiveMessage(socket.getInputStream());
                    switch(state)
                    {
                        case WAIT_MSG01:
                            processMsg01(rxMessage);
                        break;
                        case WAIT_MSG03:
                            processMsg03(rxMessage);
                        break;
                        case WAIT_MSG05:
                            processMsg05(rxMessage);
                        break;
                        case TERMINATED:
                        default:
                            assert(false);
                    }
                }
            }
            catch(IOException e)
            {
                System.err.println(e.getMessage());
            }
        }

        private void processMsg01(byte rxMessage[]) throws IOException
        {
            log("Msg01 received successfully.");
            state = ServerState.TERMINATED; // Bail out per default
            Optional<Integer> optRandom = ClientServer.parseMsg01ClientServer(rxMessage);
            if (optRandom.isPresent())
            {
                this.clientRandom = optRandom;
                Optional<byte[]> txMessage = ClientServer.generateMsg02ServerClient(clientRandom.get().intValue(), serverRandom.intValue(), serverCertificate, serverPrivateKey);
                if (txMessage.isPresent())
                {
                    ClientServer.sendMessage(txMessage.get(), socket.getOutputStream());
                    state = ServerState.WAIT_MSG03;
                    log("Sent Msg02...");
                }
            }
        }

        private void processMsg03(byte rxMessage[]) throws IOException
        {
            log("Msg03 received successfully.");
            state = ServerState.TERMINATED; // Bail out per default
            Optional<X509Certificate> optClientCert = ClientServer.parseMsg03ClientServer(rxMessage, serverRandom.intValue(), clientRandom.get().intValue());
            if (optClientCert.isPresent() && 
                ClientServer.verifyCertificate(optClientCert.get(), rootCertificate, "client.foobar.org"))
            {
                this.clientCertificate = optClientCert;
                Optional<byte[]> txMessage = 
                    ClientServer.generateMsg04ServerClient(clientRandom.get().intValue(), serverRandom, homeMadePrivPubKeys.pubKey, serverPrivateKey);
                if (txMessage.isPresent())
                {
                    ClientServer.sendMessage(txMessage.get(), socket.getOutputStream());
                    state = ServerState.WAIT_MSG05;
                    log("Sent Msg04...");
                }
            }
        }

        private void processMsg05(byte rxMessage[]) throws IOException
        {
            log("Msg05 received successfully.");
            state = ServerState.TERMINATED; // We are finished here anyways
            Optional<byte[]> optCiphertext = ClientServer.parseMsg05ClientServer(rxMessage, clientRandom.get().intValue(), serverRandom.intValue(), clientCertificate.get());

            if (optCiphertext.isPresent())
            {
                byte cleartext[] = RSA.decrypt(homeMadePrivPubKeys.d, this.homeMadePrivPubKeys.pubKey.n, optCiphertext.get());
                System.out.println("Clear Text: " + new String(cleartext));
                Pair<BigInteger, BigInteger> dsaSignature = DSA.sign(cleartext, dsaKeyPair);

                Optional<byte[]> txMessage = 
                    ClientServer.generateMsg06ServerClient(clientRandom.get().intValue(), serverRandom, dsaSignature, dsaKeyPair.publicKey, serverPrivateKey);
                if (txMessage.isPresent())
                {
                    ClientServer.sendMessage(txMessage.get(), socket.getOutputStream());
                    log("Sent Msg04...");
                }                
            }
        }

        private void log(String message)
        {
            System.out.println(message);            
            System.out.flush();
        }
    };


    public static void main(String[] args) 
    {
        final Optional<X509Certificate> optCertRoot = generateFromResource(NAME_CERT_ROOT, ClientServer::createCertificate);
        final Optional<X509Certificate> optCertServer = generateFromResource(NAME_CERT_SERVER, ClientServer::createCertificate);
        final Optional<PrivateKey> optPrivateKeyServer = generateFromResource(NAME_KEY_SERVER, ClientServer::readPrivateKey);

        if (!optCertRoot.isPresent() || !optCertServer.isPresent() || !optPrivateKeyServer.isPresent())
        {
            System.err.println("Could not read certificates and/or private key file.");
            return;
        }

        doProtocol(optCertRoot.get(), optCertServer.get(), optPrivateKeyServer.get());
    }

    private static <T> Optional<T> generateFromResource(String resourceName, Function<InputStream, Optional<T>> resourceGen)
    {
        Optional<T> ret = Optional.empty();

        try (InputStream certStream = Server.class.getClassLoader().getResourceAsStream(resourceName)) 
        {
            if (certStream != null) 
            {
                ret = resourceGen.apply(certStream);
            } 
        } catch (Exception e) 
        {
            e.printStackTrace();
        }

        return ret;
    }

    private static void doProtocol(X509Certificate certRoot, X509Certificate certServer, PrivateKey privKeyServer)
    {
        try (ServerSocket serverSocket = new ServerSocket(LISTEN_PORT)) 
        {
            System.out.println("Server is listening on port " + LISTEN_PORT);
            System.out.flush();

            while (true) 
            {
                // Accept an incoming client connection
                Socket clientSocket = serverSocket.accept();
                System.out.println("New client connected: " + clientSocket.getInetAddress());
                System.out.flush();

                ServerApp serverApp = new ServerApp(clientSocket, certRoot, certServer, privKeyServer);
                serverApp.doProtocol();

                // Close the client socket once the communication is done
                clientSocket.close();
                System.out.println("Client disconnected.");
                System.out.flush();                
            }
        }
        catch (Exception e) 
        {
            e.printStackTrace();
        }
    }
}
