/*
 * This source file was generated by the Gradle 'init' task
 */
package net.its26;

import java.io.IOException;
import java.math.BigInteger;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.Optional;

public class Client 
{
    private static final String PATH_CERT_ROOT = "/home/ernst/projects/KryptoProt/crypto_prot/KeysAndCerts/rootCA.crt";
    private static final String PATH_CERT_CLIENT = "/home/ernst/projects/KryptoProt/crypto_prot/KeysAndCerts/clientCert.crt";
    private static final String PATH_KEY_CLIENT = "/home/ernst/projects/KryptoProt/crypto_prot/KeysAndCerts/clientCert.key";
    private static final int SERVER_PORT = 12345;
    private static final String SERVER_IP = "localhost"; // Change to server's hostname or IP

    private static class ClientApp
    {
        enum ClientState
        {
            SEND_MSG01,
            WAIT_MSG02,
            WAIT_MSG04,
            WAIT_MSG06,
            TERMINATED
        }

        private final Socket socket;
        private final X509Certificate rootCertificate;
        private final X509Certificate clientCertificate;
        private final PrivateKey clientPrivateKey;
        private final Integer clientRandom;

        private ClientState state;
        private Optional<Integer> serverRandom;
        private Optional<X509Certificate> serverCertificate;
        private Optional<Pair<BigInteger, BigInteger>> serverPubKey; // own homegrown pub key

        public ClientApp(Socket socket, X509Certificate rootCertificate, X509Certificate clientCertificate, PrivateKey clientPrivateKey)
        {
            this.socket = socket;
            this.rootCertificate = rootCertificate;
            this.clientCertificate = clientCertificate;
            this.clientPrivateKey = clientPrivateKey;
            this.clientRandom = ClientServer.generateRandom();

            this.state = ClientState.SEND_MSG01;
            this.serverRandom = Optional.empty();
            this.serverCertificate = Optional.empty();
        }

        public void doProtocol()
        {
            try
            {
                // This message starts the protocol
                sendMsg01();

                while(state != ClientState.TERMINATED)
                {
                    byte rxMessage[] = ClientServer.receiveMessage(socket.getInputStream());
                    switch(state)
                    {
                        case WAIT_MSG02:
                            processMsg02(rxMessage);
                        break;
                        case WAIT_MSG04:
                            processMsg04(rxMessage);
                        break;
                        case WAIT_MSG06:
                        break;
                        case TERMINATED:
                        case SEND_MSG01:
                        default:
                            assert(false);
                    }
                }
            }
            catch(IOException e)
            {
                System.err.println(e.getMessage());
            }            
        }

        private void sendMsg01() throws IOException
        {
            byte payload[] = ClientServer.generateMsg01ClientServer(clientRandom);
            ClientServer.sendMessage(payload, socket.getOutputStream());
            state = ClientState.WAIT_MSG02;
            log("Sent Msg01: " + Common.getByteArrayAsString(payload));
        }

        private void processMsg02(byte rxMessage[]) throws IOException
        {
            log("Msg02 received successfully.");
            state = ClientState.TERMINATED; // Bail out per default
            Optional<Pair<X509Certificate, Integer>> optServerCertAndRnd = 
                ClientServer.parseMsg02ServerClient(rxMessage, clientRandom);

            if (optServerCertAndRnd.isPresent() && 
                ClientServer.verifyCertificate(optServerCertAndRnd.get().first, rootCertificate, "server.foobar.org"))
            {
                this.serverCertificate = Optional.of(optServerCertAndRnd.get().first);
                this.serverRandom = Optional.of(optServerCertAndRnd.get().last.intValue());
                Optional<byte[]> txMessage = 
                    ClientServer.generateMsg03ClientServer(clientRandom, serverRandom.get().intValue(), clientCertificate, clientPrivateKey);
                
                if (txMessage.isPresent())
                {
                    ClientServer.sendMessage(txMessage.get(), socket.getOutputStream());
                    state = ClientState.WAIT_MSG04;
                    log("Sent Msg03: " + Common.getByteArrayAsString(txMessage.get()));                    
                }
            }
        }

        private void processMsg04(byte rxMessage[]) throws IOException
        {
            state = ClientState.TERMINATED; // Bail out per default
            serverPubKey = ClientServer.parseMsg04ServerClient(rxMessage, clientRandom, serverRandom.get().intValue(), serverCertificate.get());
            if (serverPubKey.isPresent())
            {
                byte ciphertext[] = RSA.encrypt(serverPubKey.get().first, serverPubKey.get().last, "This is a secret message.".getBytes());
                Optional<byte[]> txMessage = ClientServer.generateMsg05ClientServer(clientRandom, serverRandom.get().intValue(), ciphertext, clientPrivateKey);
                if (txMessage.isPresent())
                {
                    ClientServer.sendMessage(txMessage.get(), socket.getOutputStream());
                    state = ClientState.WAIT_MSG06;
                    log("Sent Msg05: " + Common.getByteArrayAsString(txMessage.get()));
                }
            }
        }

        private void log(String message)
        {
            System.out.println(message);            
            System.out.flush();
        }        
    }


    public static void main(String[] args) 
    {
        final Optional<X509Certificate> optCertRoot = ClientServer.createCertificate(PATH_CERT_ROOT);
        final Optional<X509Certificate> optCertClient = ClientServer.createCertificate(PATH_CERT_CLIENT);
        final Optional<PrivateKey> optPrivateKeyClient = ClientServer.readPrivateKey(PATH_KEY_CLIENT);        

        if (!optCertRoot.isPresent() || !optCertClient.isPresent() || !optPrivateKeyClient.isPresent())
        {
            System.err.println("Could not read certificates and/or private key file.");
            return;
        }

        doProtocol(optCertRoot.get(), optCertClient.get(), optPrivateKeyClient.get());
    }

    private static void doProtocol(X509Certificate certRoot, X509Certificate certClient, PrivateKey privKeyClient)
    {
        try (Socket socket = new Socket(SERVER_IP, SERVER_PORT)) 
        {
            System.out.println("Connected to the server.");

            ClientApp clientApp = new ClientApp(socket, certRoot, certClient, privKeyClient);
            clientApp.doProtocol();
        } 
        catch (Exception e) 
        {
            e.printStackTrace();
        }
    }
}