/*
 * This source file was generated by the Gradle 'init' task
 */
package net.its26;

import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.Optional;
import java.util.function.Function;

public class Client 
{
    private static final String NAME_CERT_ROOT = "rootCA.crt";
    private static final String NAME_CERT_CLIENT = "clientCert.crt";
    private static final String NAME_KEY_CLIENT = "clientCert.key";
    private static final int SERVER_PORT = 12345;
    private static final String SERVER_IP = "localhost"; // Change to server's hostname or IP

    private static class ClientApp
    {
        enum ClientState
        {
            SEND_MSG01,
            WAIT_MSG02,
            WAIT_MSG04,
            WAIT_MSG06,
            TERMINATED
        }

        private final Socket socket;
        private final X509Certificate rootCertificate;
        private final X509Certificate clientCertificate;
        private final PrivateKey clientPrivateKey;
        private final String secretMessage;
        private final Integer clientRandom;

        private ClientState state;
        private Optional<Integer> serverRandom;
        private Optional<X509Certificate> serverCertificate;
        private Optional<RSA.PublicKey> serverPubKey; // own homegrown pub key

        public ClientApp(Socket socket, X509Certificate rootCertificate, X509Certificate clientCertificate, PrivateKey clientPrivateKey, String secretMessage)
        {
            this.socket = socket;
            this.rootCertificate = rootCertificate;
            this.clientCertificate = clientCertificate;
            this.clientPrivateKey = clientPrivateKey;
            this.secretMessage = secretMessage;
            this.clientRandom = ClientServer.generateRandom();

            this.state = ClientState.SEND_MSG01;
            this.serverRandom = Optional.empty();
            this.serverCertificate = Optional.empty();
            this.serverPubKey = Optional.empty();
        }

        public void doProtocol()
        {
            try
            {
                // This message starts the protocol
                sendMsg01();

                while(state != ClientState.TERMINATED)
                {
                    byte rxMessage[] = ClientServer.receiveMessage(socket.getInputStream());
                    switch(state)
                    {
                        case WAIT_MSG02:
                            processMsg02(rxMessage);
                        break;
                        case WAIT_MSG04:
                            processMsg04(rxMessage);
                        break;
                        case WAIT_MSG06:
                            processMsg06(rxMessage);
                        break;
                        case TERMINATED:
                        case SEND_MSG01:
                        default:
                            assert(false);
                    }
                }
            }
            catch(IOException e)
            {
                System.err.println(e.getMessage());
            }            
        }

        private void sendMsg01() throws IOException
        {
            byte payload[] = ClientServer.generateMsg01ClientServer(clientRandom);
            ClientServer.sendMessage(payload, socket.getOutputStream());
            state = ClientState.WAIT_MSG02;
            log("Sent Msg01...");
        }

        private void processMsg02(byte rxMessage[]) throws IOException
        {
            log("Msg02 received successfully.");
            state = ClientState.TERMINATED; // Bail out per default
            Optional<Pair<X509Certificate, Integer>> optServerCertAndRnd = 
                ClientServer.parseMsg02ServerClient(rxMessage, clientRandom);

            if (optServerCertAndRnd.isPresent() && 
                ClientServer.verifyCertificate(optServerCertAndRnd.get().first, rootCertificate, "server.foobar.org"))
            {
                this.serverCertificate = Optional.of(optServerCertAndRnd.get().first);
                this.serverRandom = Optional.of(optServerCertAndRnd.get().last.intValue());
                Optional<byte[]> txMessage = 
                    ClientServer.generateMsg03ClientServer(clientRandom, serverRandom.get().intValue(), clientCertificate, clientPrivateKey);
                
                if (txMessage.isPresent())
                {
                    ClientServer.sendMessage(txMessage.get(), socket.getOutputStream());
                    state = ClientState.WAIT_MSG04;
                    log("Sent Msg03..." );
                }
            }
        }

        private void processMsg04(byte rxMessage[]) throws IOException
        {
            log("Msg04 received successfully.");
            state = ClientState.TERMINATED; // Bail out per default
            serverPubKey = ClientServer.parseMsg04ServerClient(rxMessage, clientRandom, serverRandom.get().intValue(), serverCertificate.get());
            if (serverPubKey.isPresent())
            {
                byte ciphertext[] = RSA.encrypt(serverPubKey.get(), secretMessage.getBytes());
                Optional<byte[]> txMessage = ClientServer.generateMsg05ClientServer(clientRandom, serverRandom.get().intValue(), ciphertext, clientPrivateKey);
                if (txMessage.isPresent())
                {
                    ClientServer.sendMessage(txMessage.get(), socket.getOutputStream());
                    state = ClientState.WAIT_MSG06;
                    log("Sent Msg05...");
                }
            }
        }

        private void processMsg06(byte rxMessage[]) throws IOException
        {
            log("Msg06 received successfully.");
            state = ClientState.TERMINATED; // At this point, we are done anyways
            Optional<Pair<Pair<BigInteger, BigInteger>, DSA.PubKey>> signatureAndSigKey = 
                ClientServer.parseMsg06ServerClient(rxMessage, clientRandom, serverRandom.get().intValue(), serverCertificate.get());

            if (signatureAndSigKey.isPresent())
            {
                Pair<BigInteger, BigInteger> signature = signatureAndSigKey.get().first;
                DSA.PubKey dsaPubKey = signatureAndSigKey.get().last;

                if (DSA.verifySignature(secretMessage.getBytes(), dsaPubKey, signature))
                {
                    System.out.println("Hooray, we have gotten the proper signature for our secret string :-).");
                }
                else
                {
                    System.out.println("Nah, the DSA checksum does not match our secret string :-(.");
                }
            }
        }

        private void log(String message)
        {
            System.out.println(message);            
            System.out.flush();
        }        
    }

    public static void main(String[] args) 
    {
        final Optional<X509Certificate> optCertRoot = generateFromResource(NAME_CERT_ROOT, ClientServer::createCertificate);
        final Optional<X509Certificate> optCertClient = generateFromResource(NAME_CERT_CLIENT, ClientServer::createCertificate);
        final Optional<PrivateKey> optPrivateKeyClient = generateFromResource(NAME_KEY_CLIENT, ClientServer::readPrivateKey);

        if (!optCertRoot.isPresent() || !optCertClient.isPresent() || !optPrivateKeyClient.isPresent())
        {
            System.err.println("Could not read certificates and/or private key file.");
            return;
        }

        String secretMessage = String.join(" ", args);
        if (secretMessage.isEmpty())
        {
            secretMessage = "This is the default secret message.";
        }

        doProtocol(optCertRoot.get(), optCertClient.get(), optPrivateKeyClient.get(), secretMessage);
    }

    private static <T> Optional<T> generateFromResource(String resourceName, Function<InputStream, Optional<T>> resourceGen)
    {
        Optional<T> ret = Optional.empty();

        try (InputStream certStream = Client.class.getClassLoader().getResourceAsStream(resourceName)) 
        {
            if (certStream != null) 
            {
                ret = resourceGen.apply(certStream);
            } 
        } catch (Exception e) 
        {
            e.printStackTrace();
        }

        return ret;
    }    

    private static void doProtocol(X509Certificate certRoot, X509Certificate certClient, PrivateKey privKeyClient, String secretMessage)
    {
        try (Socket socket = new Socket(SERVER_IP, SERVER_PORT)) 
        {
            System.out.println("Connected to the server.");

            ClientApp clientApp = new ClientApp(socket, certRoot, certClient, privKeyClient, secretMessage);
            clientApp.doProtocol();
        } 
        catch (Exception e) 
        {
            e.printStackTrace();
        }
    }
}
