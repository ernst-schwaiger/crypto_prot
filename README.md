# crypto_prot
Basic Cryptographic Protocols implemented in Java

## Preconditions

- OpenSSL installed
- OpenJDK 21 installed
- gradle 8.x installed, see https://gradle.org/install/ (Version 4.x, like installed on Ubuntu, won't work!)

## Build and run tests

- run `./gradlew build`
This will generate a self-signed root certificate, client and server certificates that are signed by the root
certificate, as well as the associated keys. The certificates and keys are added to the client and server .jar files
as resources in the subsequent compilation phase.

## Get test coverage via JaCoCo

- run `./gradlew test jacocoTestReport`

## Client-Server Protocol

Client and Server exchange messages via localhost:12345/Tcp, should be visible on wireshark.

All multibyte payload entities are serialized in Big-Endian byte order, i.e. MSB comes first, LSB comes last
The first Message byte is `MsgId`, index of the message: 1..6. This is, except for Message 1, followed by `Random`,
8 random bytes, comprised by four bytes generated by the server and four bytes generated by the client. Message 1 only
transmits the four random bytes of the client. `Random` stays the same in all messages.

Client and Server generate the `Signature` field by signing all message bytes using the private key of their certificate.
In Messages 2 and 3 the peers transmit their own certificate which is then validated by the other side:
- Correct common name
- Certificate is valid
- Certificate was signed by root certificate

In Message 4, the server transmits its RSA public key. The client generates a `Ciphertext` out of a secret message using that key,
and sends the ciphertext back in Message 5.

The server decrypts the `Ciphertext`, signs the clear text with its DSA key pair, and sends the signature and the public DSA key back
to the client in Message 6. The client verifies the validity of the signature against the clear text and reports whether the verification
was successful or not.

- Message 1 (Client -> Server): MsgId | Random_Client/4Bytes
- Message 2 (Server -> Client): MsgId | Random/8Bytes | Server_Cert_Len/4Bytes | Server_Cert | Signature
- Message 3 (Client -> Server): MsgId | Random/8Bytes | Client_Cert_Len/4Bytes | Client_Cert | Signature
- Message 4 (Server -> Client): MsgId | Random/8Bytes | PubKey_e_Len/4Bytes | PubKey_m_Len/4Bytes | PubKey_e | PubKey_m | Signature
- Message 5 (Client -> Server): MsgId | Random/8Bytes | Ciphertext_Len/4Bytes | Ciphertext | Signature
- Message 6 (Server -> Client): MsgId | Random/8Bytes | PubKey_DSA_Len/4Bytes | PubKey_DSA_Signature_Len | PubKey_DSA | PubKey_DSA_Signature

To run the protocol:
- Run server via gradlew `./gradlew :server:run`.
- Run client via gradlew: `./gradlew :client:run --args <secret message>`, e.g. `./gradlew :client:run --args "This is my secret message"`

## Source Code

- `KeysAndCerts`: Script for generating certificates and keys.
- `cryptolib/src/main/java/net/its26`: 
    - `RSA.java`, `DSA.java`, `EC.java`, `SHA1.java`, `Common.java`: Crypto primitive implementations
    - `HMAC.java`, `Hash.java`, `AES.java`: generating HMACs, Hashes; encrypt/decrypt symmetric ontop of the Java crypto library
    - `ClientServer.java`: Parse functions/generation functions for the Client/Server protocol
- `cryptolib/test/java/net/its26`: Unit test classes executing the crypto primitives
- `client/src/main/java/net/its26/Client.java`: Client implementation
- `server/src/main/java/net/its26/Server.java`: Server implementation

## TODO
